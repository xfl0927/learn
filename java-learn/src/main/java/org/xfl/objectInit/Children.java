package org.xfl.objectInit;/** * @program: learn * @description: 对象初始化, 子类 * @author: xfl * @create: 2018-07-23 10:30 **/public class Children extends Parent{    /**     * 类成员变量     */    public Person person = new Person();    private static String action;    /**     * 子类无参数构造     */    public Children(){        System.out.println("子类无参数构造方法，init");    }    /**     * 子类有参数构造     * @param age     */    public Children(Integer age){        this.age = age;        System.out.println("子类有参构造方法，init");    }    /**     * 子类代码块     */    {        System.out.println("子类代码块，init");    }    /**     * 子类静态代码块     */    static {        action = "action";        staticAction();        System.out.println("子类静态代码块，init");    }    void action(){        System.out.println("子类非静态方法调用:");        staticAction();    }    static void staticAction(){        System.out.println("子类静态方法:init");    }    public static void main(String[] args) {        /**         * 静态代码块初始化，每个静态代码块只会执行一次。         * 由于JVM在加载类时会执行静态代码块和子类静态方法，所以静态代码块先于main方法执行。         * 父类先于子类执行。         */        System.out.println("************进入main函数************");        Children children = null;        /**         * 实例化Children,得到一个对象children，其中         * 先执行父类成员变量初始化、无参数代码块和父类无参数构造方法,         * 再执行子类成员变量初始化、无参数代码块和子类无参数构造方法。         */        children = new Children();        System.out.println(children.toString());        System.out.println(children.age);        System.out.println(own);        /**         * 由上可见初始化分为JVM加载类时的类初始化(静态代码块)和对象new时的初始化(无参数构造函数和构造代码块)         */    }}