package org.xfl.CallByValue;/** * @program: learn * @description: * @author: xfl * @create: 2018-09-07 16:36 **/public class CallBySwap {    /**     * 同一个类的不同Instance的引用互相交换     * @param x     * @param y     */    public static void swap(CallByReference.Man x,CallByReference.Man y){        CallByReference.Man temp = x;        x = y;        y = temp;        System.out.println("---------swap----------");        System.out.println("x-Man:"+x.toString());        System.out.println("y-Women:"+y.toString());        System.out.println("---------swap----------");    }    /**     * 如果是按照引用传值的话经过swap函数后man和women的值应该调换才对，而实际结果不是这样     * swap函数交换的只是对象引用拷贝的值，当swap函数结束后x,y将出栈被废弃，原来的man和women的值仍然是     * 调用swap函数之前对象的引用所对应的heap空间     * @param args     */    public static void main(String[] args){        CallByReference.Man man = new CallByReference.Man("man",20);        CallByReference.Man women = new CallByReference.Man("woman",18);        System.out.println("man before:" + man.toString());        System.out.println("woman before:" + women.toString());        swap(man,women);        System.out.println("after man:" + man.toString());        System.out.println("after women:" + women.toString());    }}